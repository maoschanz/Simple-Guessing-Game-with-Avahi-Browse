#include <stdlib.h>
#include <ctype.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netdb.h>
#include "dns_sd.h"
#include <stdio.h>
#include <string.h>
#include <errno.h>
#include <time.h>
#include <sys/time.h>
#include <unistd.h>
#include <arpa/inet.h>
#include <math.h>

// Macro for maximum because max and min seem to be reserved keywords in C
#define MMX(A,B) ( (A > B) ? (A) : (B))

// Calculates the log(base 2) of the function as: log_2(x) = loge(x) / loge(2);
float log_2(float k) {
	return ( (float) (log(k)/log(2)) );
}

// Generates a random number between minimum value and maximum value,
// uses the portnumber (generated by the system) as seed
int get_random_number(int mini, int maxi,int warez) {
	srand(warez);
	return ( rand() % maxi + mini );
}

// Parses the number out of a string ensuring both a bounds check and filtering of any non-numerical values
// ASSUMPTION: The string contained in *kuchi has an instance of "guess" in some form or mixture
int get_number(char * kuchi,int i, int *f) {
	int NI;

	// traverse the pointer the whole length of guess, we're only interested in what comes after guess
	kuchi = kuchi + strlen("guess");

	// sscanf lets us check for only numbers within this string and if there are any
	int ret = sscanf(kuchi,"%*[^0123456789]%d",&NI);
	int ret2 = 1;

	// check for any other clutter other than numbers within string kuchi
	for(char *cc = kuchi; (*cc) != '\0'; cc++ ) {
		if( ( ((*cc) >= 'a') && ( (*cc) <= 'z' ) ) || ( ((*cc) >= 'A') && ( (*cc) <= 'Z' ) )) {
			ret2 = 0;
			break;
		}
	}

	// CASE: guess written without a nunmber DISCARD resets f flag
	if (ret == 0) {
		char w[100];
		sprintf(w,"\n ??? \n");
		write(i,w,strlen(w)+1);
		(*f) = 0;
		return 0;
	}

	// CASE: guess has extra clutter NOT ALLOWED DISCARD resets f flag
	if (ret2 == 0) {
		char w[100];
		sprintf(w,"\n ??? \n");
		write(i,w,strlen(w)+1);
		(*f) = 0;
		return 0;
	}

	// CASE: Both number and guess present but NUMBER OUT OF RANGE DISCARD resets f flag
	if(NI > 100 || NI < 1) {
		char w[100];
		sprintf(w,"\n ??? \n");
		write(i,w,strlen(w)+1);
		(*f) = 0;
		return 0;
	}

	return NI;
}

// handles the client connection and closes it accordingly
void handle_client(int i, int port__NO, fd_set * masta) {
	char w[500],str[100];
	char * cc = "guess";

	// stup_flug SET
	int stup_flug = 1, guess_count = 0;
	// get random number, notice how random port number used for random number
	int random_no = get_random_number(1,100,port__NO);

	sprintf(w,"\n Guess a number: \n");
	write(i,w,strlen(w) + 1);

	// while loop, stopped by stup_flug flag
	while(stup_flug) {
		bzero(str,100);
		// Read string from the client
		read(i,str,100);

		// Convert all characters to lower, makes it easy to process
		for(char *ptr = str; *ptr!='\0'; ptr++) { *ptr = tolower(*ptr); }
		// Find given substring "guess" if it exists in the complete string
		char *puchi = strstr(str,cc);

		if(puchi!=NULL) {
			int f = 6,*ff;
			// Initialize handlers
			ff = &f;

			// get a random no b/w 0 and 1
			int no = get_number(puchi,i,ff);

			// ff (called f flag in get_number) flag set PROCEED
			if((*ff) != 0) {
				if(no == random_no) { // CORRECT condition
					bzero(w,500);
					sprintf(w,"\n CORRECT \n");
					write(i,w,strlen(w)+1);
					guess_count++;
					stup_flug = 0;
					// stup_flug RESET, WHILE LOOP ENDS
				} else if(no < random_no) { // GREATER condition
					bzero(w,500);
					sprintf(w,"\n GREATER \n");
					guess_count++;
					write(i,w,strlen(w)+1);
				} else { // SMALLER condition
					bzero(w,500);
					sprintf(w,"\n SMALLER \n");
					guess_count++;
					write(i,w,strlen(w)+1);
				}
			}
		} else {
			// guess is not present in the string at all unknown input ???
			bzero(w,500);
			sprintf(w,"\n ??? \n");
			write(i,w,strlen(w)+1);
		}
	}

	if( guess_count < (log_2(100) - 1) ) {
		// GREAT GUESSING
		bzero(w,500);
		sprintf(w,"\n GREAT GUESSING \n");
		write(i,w,strlen(w)+1);
	} else if(guess_count > (log_2(100) + 1)) {
		// BETTER LUCK NEXT TIME
		bzero(w,500);
		sprintf(w,"\n BETTER LUCK NEXT TIME \n");
		write(i,w,strlen(w)+1);
	} else {
		// MEDIOCRE GUESS
		bzero(w,500);
		sprintf(w,"\n AVERAGE \n");
		write(i,w,strlen(w)+1);
	}

	// closes connection and clears file descriptor of socket from the master (duplicate) file descriptor set
	close(i);
	FD_CLR(i,masta);
}

// Callback function
static void RegstCallback(
	DNSServiceRef serv,
	DNSServiceFlags all_DNS_flags,
	DNSServiceErrorType EC,
	const char * nomme,
	const char * type,
	const char * domain,
	void * context
) {
#pragma unused(flags)
#pragma unused(context)

	if (EC != kDNSServiceErr_NoError) {
		fprintf(stderr, "Error Code received::: %d\n", EC);
	} else {
		printf(" NAME:: %s TYPE:: %s DOMAIN:: %s \n", nomme, type, domain);
	}
}

// Runs the server
static DNSServiceErrorType Run_Avahi_Server() {
	DNSServiceErrorType error;
	DNSServiceErrorType err;
	DNSServiceRef serviceRef;

	int listn_file_descp;
	int on = 1;

	// sockaddr_in defined
	struct sockaddr_in servaddr;

	// listening socket created
	listn_file_descp = socket(AF_INET, SOCK_STREAM, IPPROTO_TCP);
	setsockopt(listn_file_descp, SOL_SOCKET, SO_REUSEADDR, (char*)&on, sizeof(int));
	bzero( &servaddr, sizeof(servaddr));

	servaddr.sin_family = AF_INET;
	servaddr.sin_addr.s_addr = htons(INADDR_ANY);
	servaddr.sin_port = htons(0);
	// socket address structure initialized

	// bind the socket
	bind(listn_file_descp, (struct sockaddr_in *) &servaddr, sizeof(servaddr));

	listen(listn_file_descp, 10);
	int s_len = sizeof(servaddr);

	// current object socket is bound to
	getsockname(listn_file_descp,&servaddr,&(s_len));

	// advertising the service
	error = DNSServiceRegister(
		&serviceRef,
		0,
		0,
		" dassg ",
		"_gtn._tcp",
		"local",
		NULL,
		servaddr.sin_port,
		0,
		NULL,
		RegstCallback,
		NULL
	);

	int dns_file_descp = DNSServiceRefSockFD(serviceRef);
	int max_file_descp;

	fd_set fdset, masta;

	FD_ZERO(&fdset);
	FD_ZERO(&masta);
	// file descriptor sets for select() call made ready by setting to zero

	FD_SET(dns_file_descp,&masta);
	FD_SET(listn_file_descp,&masta);
	max_file_descp = MMX(dns_file_descp,listn_file_descp);

	// file descp. used for accept
	int commu_file_descp = 0;

	// infinite loop
	while(1) {
		memcpy(&fdset,&masta,sizeof(masta));
		int ret = select(max_file_descp+1,&fdset,(fd_set*)NULL, (fd_set*)NULL,0);

		for(int i = 0; i <=max_file_descp && ret > 0; i++ ) {
			if( FD_ISSET(i,&fdset) ) {
				ret--;

				// handle zeroconf
				if(i == dns_file_descp) {
					err = DNSServiceProcessResult(serviceRef);
					if(err) {
						printf("\nError exiting!!\n");
						exit(1);
					}
				} else if(i == listn_file_descp) { // something found on the listening socket
					// accept gives new port where this new client is found
					commu_file_descp = accept(listn_file_descp, (struct sockaddr_in *) NULL,(struct sockaddr_in *) NULL );

					if(commu_file_descp == -1) {
						printf("\n Error due to accept fail!! \n");
					}

					// added to master file descriptor
					FD_SET(commu_file_descp,&masta);

					// if max file descriptor lesser than commu_file_descp then set to it
					if(max_file_descp < commu_file_descp ) {
						max_file_descp = commu_file_descp;
					}
				} else {
					// a client fd, play game with client (single client server so one user at a time)
					handle_client(i,servaddr.sin_port,&masta);
				}

			}
		}
	}

	// deallocate serviceRef
	DNSServiceRefDeallocate(serviceRef);
	return error;
}

int main() {
	DNSServiceErrorType error = Run_Avahi_Server();
	return 1;
}

